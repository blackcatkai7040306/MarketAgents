from datetime import datetime
import json
import logging
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field

from zi_agent.ziagents import ZIAgent, Order, Trade
from base_agent.agent import Agent as LLMAgent
from zi_agent.schema import MarketActionSchema

logger = logging.getLogger(__name__)

class MarketAgent(BaseModel):
    zi_agent: ZIAgent
    llm_agent: LLMAgent
    memory: List[Dict[str, Any]] = Field(default_factory=list)
    use_llm: bool = Field(default=False, description="Whether to use LLM for decision making")

    class Config:
        arbitrary_types_allowed = True

    @classmethod
    def create(cls, agent_id: int, is_buyer: bool, num_units: int, base_value: float, use_llm: bool,
               max_relative_spread: float = 0.2, llm_config: Dict[str, Any] = None):
        zi_agent = ZIAgent.generate(agent_id, is_buyer, num_units, base_value, max_relative_spread)
        
        role = "buyer" if is_buyer else "seller"
        llm_agent = LLMAgent(role=role, llm_config=llm_config or {}, output_format="MarketActionSchema")

        return cls(zi_agent=zi_agent, llm_agent=llm_agent, use_llm=use_llm)

    def generate_bid(self, market_info: dict, round_num: int) -> Optional[Order]:
        if self.use_llm:
            return self._generate_llm_bid(market_info, round_num)
        else:
            return self.zi_agent.generate_bid()
        
    def _generate_llm_bid(self, market_info: dict, round_num: int) -> Optional[Order]:
        market_info_str = self._get_market_info(market_info)
        recent_memories = self.get_recent_memories(2)
        memory_str = self._format_memories(recent_memories)

        task_prompt = f"Generate a market action based on the following market information: {market_info_str}"
        
        if memory_str:
            task_prompt += f"\n\nRecent market activities:\n{memory_str}"
        
        llm_response = self.llm_agent.execute(task_prompt)

        self.log_interaction(round_num, task_prompt, llm_response)

        logger.info("---LLM JSON RESPONSE---")
        logger.info(json.dumps(json.loads(llm_response), indent=2))
        try:
            market_action = MarketActionSchema.parse_raw(llm_response)
            if market_action.action == "hold":
                return None
            
            bid = market_action.bid
            bid.quantity = 1  # Force quantity to be 1 for now
            
            zi_bid = self.zi_agent.generate_bid()
            
            if self.zi_agent.preference_schedule.is_buyer:
                base_value = self.zi_agent.preference_schedule.get_value(self.zi_agent.allocation.goods + bid.quantity)
                base_cost = None
            else:
                base_value = None
                base_cost = self.zi_agent.preference_schedule.get_value(self.zi_agent.allocation.initial_goods - self.zi_agent.allocation.goods + bid.quantity)
            
            try:
                order = Order(
                    agent_id=self.zi_agent.id,
                    is_buy=self.zi_agent.preference_schedule.is_buyer,
                    quantity=bid.quantity,
                    price=bid.price,
                    base_value=base_value,
                    base_cost=base_cost
                )
                return order
            except ValueError as ve:
                logger.error(f"Invalid order generated by LLM for agent {self.zi_agent.id}: {ve}")
                return None
        except Exception as e:
            logger.error(f"Error parsing LLM response: {e}")
            return None
    
    def log_interaction(self, round_num: int, task_prompt: str, response: str):
        interaction = {
            "round": round_num,
            "task": task_prompt,
            "response": response,
            "timestamp": datetime.now().isoformat()
        }
        self.memory.append(interaction)

    def get_recent_memories(self, n: int) -> List[Dict[str, Any]]:
        return self.memory[-n:]

    def _format_memories(self, memories: List[Dict[str, Any]]) -> str:
        if not memories:
            return ""
        formatted_memories = []
        for memory in memories:
            formatted_memories.append(f"Round {memory['round']}:\nTask: {memory['task'].split('Recent market activities:')[0].strip()}\nResponse: {memory['response']}\n")
        return "\n".join(formatted_memories)  
    
    def _get_market_info(self, market_info: dict) -> str:
        return f"""
        Current Cash: {round(self.zi_agent.allocation.cash, 2)}
        Current Goods: {self.zi_agent.allocation.goods}
        Last Trade Price: {round(market_info['last_trade_price'], 2) if market_info['last_trade_price'] is not None else 'N/A'}
        Average Market Price: {round(market_info['average_price'], 2) if market_info['average_price'] is not None else 'N/A'}
        Total Trades: {market_info['total_trades']}
        Current Round: {market_info['current_round']}
        Base Value/Cost: {round(self.zi_agent.preference_schedule.get_value(self.zi_agent.allocation.goods + 1), 2)}
        """

    def finalize_trade(self, trade: Trade):
        self.zi_agent.finalize_trade(trade)

    def respond_to_order(self, order: Order, accepted: bool):
        self.zi_agent.respond_to_order(order, accepted)

    def calculate_trade_surplus(self, trade: Trade) -> float:
        return self.zi_agent.calculate_trade_surplus(trade)

    def calculate_individual_surplus(self) -> float:
        return self.zi_agent.calculate_individual_surplus()

    def plot_order_history(self):
        self.zi_agent.plot_order_history()